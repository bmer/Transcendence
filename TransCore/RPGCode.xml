<?xml version="1.0" encoding="utf-8"?>

<TranscendenceModule>
	<Globals>
		(block Nil

			(setq rpgAdjustInstallPrice (lambda (theObj theItem thePriceAdj theCurrency)
				(switch
					(isInt thePriceAdj)
						(divide
							(multiply thePriceAdj (itmGetInstallCost theItem theCurrency))
							100
							)

					(isFunction thePriceAdj)
						(apply thePriceAdj theItem Nil)

					(itmGetInstallCost theItem theCurrency)
					)
				))

			(setq rpgAdjustPrice (lambda (theObj theItem thePriceAdj theCurrency noInventoryCheck)
				(switch
					(isInt thePriceAdj)
						(divide
							(multiply thePriceAdj (itmGetPrice theItem theCurrency))
							100
							)

					(isFunction thePriceAdj)
						(apply thePriceAdj theItem Nil)

					(objGetSellPrice theObj theItem noInventoryCheck)
					)
				))

			(setq rpgBuyItem (lambda (theObj theItem thePrice theCurrency)
				(block Nil
					; Add to player ship
					(objAddItem gPlayerShip theItem)
					
					; Charge the player
					(objCharge gPlayerShip theCurrency thePrice)
					(plyRecordBuyItem gPlayer theItem theCurrency thePrice)

					; Add to station balance
					(objCredit gSource theCurrency thePrice)

					; If the player bought items at a black market station then
					; increase xp
					(if (and
							(objHasAttribute theObj "blackmarket")
							(itmHasModifier theItem "Illegal")
							)
						(objIncData gPlayerShip "blackMarketXP" (divide thePrice 100))
						)
						
					; Remember that we've bought something, for tutorial 
					; purposes.
					(typSetData &svPlayer; 'tutorialBought True)
					)
				))
				
			(setq rpgDockServices (lambda (targetObj options)
				(block Nil
				
					;	For now we only support the player ship
					
					(if (not (eq targetObj gPlayerShip))
						(error "rpgDockServices only support gPlayerShip.")
						)
						
					;	Show the appropriate dock services screen based on the ship
					;	class.
					
					(scrShowScreen gScreen
						(objGetProperty targetObj 'dockServicesScreen)
						options
						)
					)
				))
				
			(setq rpgCalcDockServiceArmorAction (lambda (dockObj shipObj options)
				(block (
					(armorForSale 
						(filter (objGetItems dockObj "aUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetArmorReplacePrice dockObj theItemToBuy)
									)
							)
						)
					(armorInCargo (objGetItems shipObj "aU"))
					(armorToInstall
						(filter armorInCargo theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installItemStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(shieldsForSale 
						(filter (objGetItems dockObj "sUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									)
							)
						)
					(shieldsToInstall
						(filter (objGetItems shipObj "sU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(maxArmorLevel (map armorForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(maxShieldsLevel (map shieldsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(maxRepairArmorLevel (objGetProperty dockObj 'repairArmorMaxLevel))
					
					(minPlayerArmorLevel (map (objGetItems shipObj "aI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					(minPlayerShieldsLevel (map (objGetItems shipObj "sI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:shipConfig")
										(typTranslate &dsRPGDockServicesBase; "actionArmor:shipConfig")
										)
								}
								
						;	If we have upgrades
						
						(and armorForSale
								(geq maxArmorLevel minPlayerArmorLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:armorAbility" { items:armorForSale maxLevel:maxArmorLevel })
										(scrTranslate gScreen "actionArmor:defaultArmorUpgrade" { items:armorForSale maxLevel:maxArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorUpgrade" { items:armorForSale maxLevel:maxArmorLevel })
										)
								}
						
						(and shieldsForSale
								(geq maxShieldsLevel minPlayerShieldsLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:shieldsAbility" { items:shieldsForSale maxLevel:maxShieldsLevel })
										(scrTranslate gScreen "actionArmor:defaultShieldsUpgrade" { items:shieldsForSale maxLevel:maxShieldsLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultShieldsUpgrade" { items:shieldsForSale maxLevel:maxShieldsLevel })
										)
								}
						
						;	If we can install something for the player
						
						armorToInstall
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultArmorInstall" { items:armorToInstall maxLevel:(objGetProperty dockObj 'installArmorMaxLevel) })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorInstall" { items:armorToInstall maxLevel:(objGetProperty dockObj 'installArmorMaxLevel) })
										)
								}
								
						shieldsToInstall
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultShieldsInstall" { items:shieldsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultShieldsInstall" { items:shieldsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	Can we repair the player's armor?
						
						(geq maxRepairArmorLevel minPlayerArmorLevel)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionArmor:defaultArmorRepair" { maxLevel:maxRepairArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:defaultArmorRepair" { maxLevel:maxRepairArmorLevel })
										)
								}
								
						maxRepairArmorLevel
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionArmor:noTechToRepair" { maxLevel:maxRepairArmorLevel })
										(typTranslate &dsRPGDockServicesBase; "actionArmor:noTechToRepair" { maxLevel:maxRepairArmorLevel })
										)
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (or (scrTranslate gScreen "actionArmor:nothing")
									(typTranslate &dsRPGDockServicesBase; "actionArmor:nothing")
									)
							}
						)
					)
				))
			
			(setq rpgCalcDockServiceBuyAmmo (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
							
					;	If this item does not require ammo, then we hide the action
					
					(not (itmGetProperty theItem 'ammoType))
						{
							visible: Nil
							}
							
					;	If the station doesn't have any ammo to sell, then we disabled and
					;	explain.
					
					(not (filter (objGetItems dockObj (cat "m +launchedBy:" (itmGetType theItem) ";")) theItemToBuy
							(objGetSellPrice dockObj theItemToBuy)
							))
						{
							visible: True
							enabled: Nil
							desc: 
								(if (= (@ options 'category) 'launcher)
									(scrTranslate gScreen "actionBuyMissiles:noMissilesToBuy" { item:theItem })
									(scrTranslate gScreen "actionBuyAmmo:noAmmoToBuy" { item:theItem })
									)
							}
							
					;	Otherwise, we do have some
					
					{
						visible: True
						enabled: True
						desc:
							(if (= (@ options 'category) 'launcher)
								(scrTranslate gScreen "actionBuyMissiles:missilesForSale" { item:theItem })
								(scrTranslate gScreen "actionBuyAmmo:ammoForSale" { item:theItem })
								)
						}
					)
				))
				
			(setq rpgCalcDockServiceInstallAction (lambda (dockObj shipObj options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	If no items to install, action is disabled
					
					(not (objGetItems shipObj (@ options 'criteria)))
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionInstall:noItemInCargo" { category:(@ options 'category) })
							}
							
					;	If none of the items in our cargo hold can be installed because
					;	the station requires an upgrade (purchase) then we show an error.
					
					(not (filter (objGetItems shipObj (@ options 'criteria)) theItemToInstall
							(not (@ (objGetItemProperty dockObj theItemToInstall 'installItemStatus) 'upgradeInstallOnly))
							))
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionInstall:upgradeInstallOnly" { category:(@ options 'category) })
							}
							
					{
						visible: True
						enabled: True
						desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) })
								(scrTranslate gScreen "actionInstall:defaultAbility" { category:(@ options 'category) dockObj:dockObj })
								)
						}
					)
				))
				
			(setq rpgCalcDockServiceMiscDevicesAction (lambda (dockObj shipObj options)
				(block (
					(itemsForSale 
						(filter (objGetItems dockObj "d~wsUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									)
							)
						)
					(itemsToInstall
						(filter (objGetItems shipObj "d~wsU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(itemsToRemove
						(filter (objGetItems shipObj "d~wsrI") theItemToRemove
							(block (
								(removeStatus (objGetItemProperty dockObj theItemToRemove 'removeItemStatus))
								)
								(and (@ removeStatus 'canRemove)
									(not (@ removeStatus 'upgradeInstallOnly))
									)
								)
							)
						)
						
					(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:shipConfig")
								}
								
						;	If we have upgrades
						
						itemsForSale
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:miscDevicesAbility" { items:itemsForSale maxLevel:maxLevel })
										(scrTranslate gScreen "actionMiscDevices:defaultUpgrade" { items:itemsForSale maxLevel:maxLevel })
										)
								}
						
						;	If we can install something for the player
						
						itemsToInstall
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultInstall" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}
								
						;	If we can remove something for the player
						
						itemsToRemove
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionMiscDevices:defaultRemove" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionMiscDevices:nothing")
							}
						)
					)
				))
			
			(setq rpgCalcDockServiceRefuelAction (lambda (dockObj shipObj options)
				(block (
					(currencyUsed (objGetDefaultCurrency dockObj))
					(fuelToUse (objGetRefuelItemAndPrice dockObj shipObj))
					(fuelItem (@ fuelToUse 0))
					(cost (@ fuelToUse 1))
					(maxCount (if fuelToUse (shpGetFuelNeeded shipObj fuelItem) 0))
					(maxAfford (if (gr cost 0) (divide (objGetBalance shipObj currencyUsed) cost) 0))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: Nil
								}
								
						(not (objGetProperty dockObj 'refuelMaxLevel))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noRefuel")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noRefuel")
										)
								}
								
						(not fuelToUse)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noCompatibleFuel")
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noCompatibleFuel")
										)
								}
								
						(and (= cost 0) (= maxCount 0))
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										)
								}
								
						(= cost 0)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:freeRefuel" { item:fuelItem needed:maxCount })
										)
								
								fuelItem: fuelItem
								cost: cost
								maxCount: maxCount
								maxAfford: maxAfford
								maxNeeded: maxCount
								}
								
						(= maxCount 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:noFuelNeeded" { item:fuelItem })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:noFuelNeeded" { item:fuelItem })
										)
								}
								
						(= maxAfford 0)
							{
								visible: True
								enabled: Nil
								desc: (or (scrTranslate gScreen "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										)
								}
								
						(ls maxAfford maxCount)
							{
								visible: True
								enabled: True
								desc: (or (scrTranslate gScreen "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										(typTranslate &dsRPGDockServicesBase; "actionRefuel:cantAfford" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount afford:maxAfford })
										)
								
								fuelItem: fuelItem
								cost: cost
								maxCount: maxAfford
								maxAfford: maxAfford
								maxNeeded: maxCount
								}
								
						{
							visible: True
							enabled: True
							desc: (or (scrTranslate gScreen "actionRefuel:refuel" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount })
									(typTranslate &dsRPGDockServicesBase; "actionRefuel:refuel" { item:fuelItem cost:(fmtCurrency currencyUsed cost) needed:maxCount })
									)
								
							fuelItem: fuelItem
							cost: cost
							maxCount: maxCount
							maxAfford: maxAfford
							maxNeeded: maxCount
							}
						)
					)
				))
				
			(setq rpgCalcDockServiceRemoveAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
							
					;	For devices, excluding reactors
					
					(itmMatches theItem "d~rI")
						(block (
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							(costToRemove (@ dockStatus 'price))
							)
							
							(switch
								(@ dockStatus 'upgradeInstallOnly)
									{
										visible: Nil	;	The Replace action already shows the message, so no need to repeat
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:upgradeInstallOnly" { item:theItem })
										}
										
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:noTech" { item:theItem })
										}
										
								(not (isint itemStatus))
									{
										visible: True
										enabled: Nil
										desc: itemStatus
										}
								
								(not (eq itemStatus 0))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:cannotRemove" { item:theItem })
										}
								
								(gr (itmGetMass theItem) (objGetCargoSpaceLeft shipObj))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:noRoomInCargo")
										}
								
								(ls (objGetBalance shipObj currencyUsed) costToRemove)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionRemove:cannotAfford" { cost:(fmtCurrency currencyUsed costToRemove) })
										cost: costToRemove
										}
								
								(eq costToRemove 0)
									{
										visible: True
										enabled: True
										desc: (scrTranslate gScreen "actionRemove:freeRemove")
										cost: 0
										}

								{
									visible: True
									enabled: True
									desc: (scrTranslate gScreen "actionRemove:remove" { cost:(fmtCurrency currencyUsed costToRemove) })
									cost: costToRemove
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceRepairAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	If armor segment...
					
					(= (itmGetProperty theItem 'category) 'armor)
						(block (
							(damage (objGetArmorDamage shipObj theItem))
							(maxHP (shpGetArmorMaxHitPoints shipObj theItem))
							(currencyUsed (objGetDefaultCurrency dockObj))
							(costToRepair (objGetArmorRepairPrice dockObj theItem damage))
							(armorNoun (cat (objGetArmorName shipObj theItem) " " (itmGetName theItem 0x20)))
							)
							
							(switch
								(eq damage 0)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorNotDamaged { armorNoun:armorNoun })
										}

								(gr (itmGetProperty theItem 'repairLevel) (objGetProperty dockObj 'repairArmorMaxLevel))
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorNoTech { armorNoun:armorNoun })
										}
										
								(not costToRepair)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorCantRepair { armorNoun:armorNoun })
										}

								(ls (subtract maxHP damage) (divide maxHP 4))
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorTooMuchDamage { armorNoun:armorNoun })
										}

								(ls (objGetBalance shipObj currencyUsed) costToRepair)
									{
										visible: True
										enabled: Nil
										desc: (typTranslate &dsRPGManageArmor; 'descArmorCantAfford { armorNoun:armorNoun cost:(fmtCurrency currencyUsed costToRepair) })
										cost: costToRepair
										}

								(eq costToRepair 0)
									{
										visible: True
										enabled: True
										desc: (typTranslate &dsRPGManageArmor; 'descArmorFreeRepair { armorNoun:armorNoun })
										cost: 0
										}

								{
									visible: True
									enabled: True
									desc: (typTranslate &dsRPGManageArmor; 'descArmorRepair { armorNoun:armorNoun cost:(fmtCurrency currencyUsed costToRepair) })
									cost: costToRepair
									}
								)
							)
							
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceReplaceAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	For armor
					
					(itmMatches theItem "aI")
						(block (
							(itemsAvail 
								(filter (objGetItems shipObj (@ options 'criteria)) theItemInCargo
									(not (itmIsEqual theItemInCargo theItem 'ignoreInstalled))
									)
								)
							(maxLevel (map itemsAvail 'reduceMax theItemInCargo (itmGetLevel theItemInCargo)))
							)
							
							(switch
								(not itemsAvail)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noItemInCargo" { category:(@ options 'category) item:theItem })
										}
										
								(ls maxLevel (itmGetLevel theItem))
									{
										visible: True
										enabled: True
										desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxLevel })
												(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
												)
										}
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) })
											(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj })
											)
									}
								)
							)
							
					;	For all devices
					
					(itmMatches theItem "dI")
						(block (
							(itemsAvail 
								(filter (objGetItems shipObj (@ options 'criteria)) theItemInCargo
									(not (itmIsEqual theItemInCargo theItem 'ignoreInstalled))
									)
								)
							(maxLevel (map itemsAvail 'reduceMax theItemInCargo (itmGetLevel theItemInCargo)))
						
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							)
							
							(switch
								(not (isint itemStatus))
									{
										visible: Nil	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: itemStatus
										}
								
								(not (eq itemStatus 0))
									{
										visible: Nil	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:cannotReplace" { item:theItem })
										}
								
								(@ dockStatus 'upgradeInstallOnly)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:upgradeInstallOnly" { item:theItem })
										}
										
								(not itemsAvail)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noItemInCargo" { category:(@ options 'category) })
										}
								
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:noTech" { item:theItem })
										}
										
								(ls maxLevel (itmGetLevel theItem))
									{
										visible: True
										enabled: True
										desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) maxLevel:maxLevel })
												(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
												)
										}
										
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:installAbility" { category:(@ options 'category) })
											(scrTranslate gScreen "actionReplace:defaultAbility" { category:(@ options 'category) dockObj:dockObj })
											)
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceUpgradeAction (lambda (dockObj shipObj theItem options)
				(switch
					(= dockObj shipObj)
						{
							visible: Nil
							}
				
					;	For installing a new device
					
					(and (not theItem) (!= (@ options 'category) 'armor))
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItem (itmGetLevel theItem)))
							)
							
							(switch
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
										}
					
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							)
				
					;	For armor
					
					(itmMatches theItem "aI")
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetArmorReplacePrice dockObj theItemToBuy)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
							(maxLevelUpgrade
								(map itemsForSale 'reduceMax theItemToBuy 
									(if (not (itmIsEqual theItemToBuy theItem 'ignoreInstalled))
										(itmGetLevel theItemToBuy)
										0
										)
									)
								)
							)
							
							(switch
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
										}
										
								(ls maxLevelUpgrade (itmGetLevel theItem))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:noItemUpgrade" { category:(@ options 'category) item:theItem })
										}
					
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							)
							
					;	For all devices (except miscellaneous devices)
					
					(and (itmMatches theItem "dI")
							(!= (@ options 'category) 'device)
							)
						(block (
							(itemsForSale 
								(filter (objGetItems dockObj (@ options 'criteria)) theItemToBuy
									(and (objGetSellPrice dockObj theItemToBuy)
											(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
											)
									)
								)
							(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
							(maxLevelUpgrade
								(map itemsForSale 'reduceMax theItemToBuy 
									(if (not (itmIsEqual theItemToBuy theItem 'ignoreInstalled))
										(itmGetLevel theItemToBuy)
										0
										)
									)
								)
						
							(currencyUsed (objGetDefaultCurrency dockObj))
							(itemStatus (shpCanRemoveDevice shipObj theItem))
							(dockStatus (objGetItemProperty dockObj theItem 'removeItemStatus))
							)
							
							(switch
								(not (isint itemStatus))
									{
										visible: Nil	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: itemStatus
										}
								
								(not (eq itemStatus 0))
									{
										visible: Nil	;	If we cannot be removed, then the Remove action will show the error
										enabled: Nil
										desc: (scrTranslate gScreen "actionReplace:cannotReplace" { item:theItem })
										}
								
								(not itemsForSale)
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:noItemForSale" { category:(@ options 'category) })
										}
								
								(ls maxLevelUpgrade (itmGetLevel theItem))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:noItemUpgrade" { category:(@ options 'category) item:theItem })
										}
										
								(not (@ dockStatus 'canRemove))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:noTech" { item:theItem })
										}
										
								(not (isint itemStatus))
									{
										visible: True
										enabled: Nil
										desc: itemStatus
										}
								
								(not (eq itemStatus 0))
									{
										visible: True
										enabled: Nil
										desc: (scrTranslate gScreen "actionUpgrade:cannotUpgrade" { item:theItem })
										}
								
								{
									visible: True
									enabled: True
									desc: (or (objTranslate dockObj "dockServices:upgradeAbility" { category:(@ options 'category) maxLevel:maxLevel })
											(scrTranslate gScreen "actionUpgrade:defaultAbility" { category:(@ options 'category) dockObj:dockObj maxLevel:maxLevel })
											)
									}
								)
							
							)
				
					;	Otherwise, not supported
					
					{
						visible: Nil
						}
					)
				))
				
			(setq rpgCalcDockServiceWeaponsAction (lambda (dockObj shipObj options)
				(block (
					(itemsForSale 
						(filter (objGetItems dockObj "wUN") theItemToBuy
							(and (objGetSellPrice dockObj theItemToBuy)
									(objGetItemProperty dockObj theItemToBuy 'installDevicePrice)
									)
							)
						)
					(itemsToInstall
						(filter (objGetItems shipObj "wU") theItemToInstall
							(block (
								(installStatus (objGetItemProperty dockObj theItemToInstall 'installDeviceStatus))
								)
								(and (@ installStatus 'canInstall)
									(not (@ installStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(itemsToRemove
						(filter (objGetItems shipObj "wI") theItemToRemove
							(block (
								(removeStatus (objGetItemProperty dockObj theItemToRemove 'removeItemStatus))
								)
								(and (@ removeStatus 'canRemove)
									(not (@ removeStatus 'upgradeInstallOnly))
									)
								)
							)
						)
					(ammoWeapons (filter (objGetItems shipObj "wI") theItem
						(itmGetProperty theItem 'ammoType)
						))
					(ammoForSale
						(filter (objGetItems dockObj "m") theItem
							(and
								(objGetSellPrice dockObj theItem)
								(filter ammoWeapons theWeapon
									(itmMatches theItem (cat "m +launchedBy:" (itmGetType theWeapon) ";"))
									)
								)
							)
						)
						
					(maxLevel (map itemsForSale 'reduceMax theItemToBuy (itmGetLevel theItemToBuy)))
					(minPlayerLevel (map (objGetItems shipObj "wI") 'reduceMin theItemToUpgrade (itmGetLevel theItemToUpgrade)))
					)
					
					(switch
						(= dockObj shipObj)
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionWeapons:shipConfig")
								}
								
						;	If we have upgrades
						
						(and itemsForSale
								(geq maxLevel minPlayerLevel)
								)
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:weaponsAbility" { items:itemsForSale maxLevel:maxLevel })
										(scrTranslate gScreen "actionWeapons:defaultUpgrade" { items:itemsForSale maxLevel:maxLevel })
										)
								}
						
						;	If we can install something for the player
						
						itemsToInstall
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultInstall" { items:itemsToInstall maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	If we can sell ammo
						
						ammoForSale
							{
								visible: True
								enabled: True
								desc: (scrTranslate gScreen "actionWeapons:defaultAmmo" { items:ammoForSale maxLevel:(map ammoForSale 'reduceMax theItem (itmGetLevel theItem)) })
								}
								
						;	If we can remove items
						
						itemsToRemove
							{
								visible: True
								enabled: True
								desc: (or (objTranslate dockObj "dockServices:installAbility" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										(scrTranslate gScreen "actionWeapons:defaultRemove" { items:itemsToRemove maxLevel:(objGetProperty dockObj 'installDeviceMaxLevel) })
										)
								}
								
						;	No upgrades for player
						
						itemsForSale
							{
								visible: True
								enabled: Nil
								desc: (scrTranslate gScreen "actionWeapons:noBetterUpgrades" { maxLevel:maxLevel })
								}
								
						;	Otherwise, nothing
						
						{
							visible: True
							enabled: Nil
							desc: (scrTranslate gScreen "actionWeapons:nothing")
							}
						)
					)
				))
				
			;	rpgCalcToHit
			;
			;	This is a generic function useful for calculating probability of
			;	something happending when you have an attack value and a defense
			;	value.
			;
			;	attack and defense must both be between 0 and 100. The result is
			;	a probability of success from 0 to 100.
			;
			;	See: https://forums.kronosaur.com/viewtopic.php?p=63206#p63206
				
			(setq rpgCalcToHit (lambda (attack defense)
				(switch
					(leq attack 0)
						0
						
					(leq defense 0)
						attack
						
					(divide (* attack attack) (+ attack defense))
					)
				))
			
			;	rpgGetInstallerList
			;
			;	Returns a list of objects that are able to install the given item
			;	on the given ship. The objects are returned in a list sorted
			;	by distance to the ship.
			
			(setq rpgGetInstallerList (lambda (theShip theItem)
				(filter (sysFindObject theShip "TAF +populated; S:d") theObj
					(block (
						(installStatus (objGetItemProperty theObj theItem 'installDeviceStatus))
						)
													
						(and (@ installStatus 'canInstall)
							(not (@ installStatus 'upgradeInstallOnly))
							)
						)
					)
				))

			(setq rpgGetReactorUpgradeList (lambda (theObj theShip theCriteria)
				(block (minPower reactorList additionalList)

					; Compute the current reactor power of the player ship
					; NOTE: We have to multiply by 100 to get to kilowatts
					(setq minPower (multiply (objGetMaxPower theShip) 100))

					; Make a list of reactor items, filtering out any that are
					; too small for the ship.
					(setq reactorList (map (itmGetTypes theCriteria) 'excludeNil theUNID
						(switch

							; If this reactor has less power than the player's
							; current reactor, then skip it.
							(leq (typGetDataField theUNID 'power) minPower)
								Nil

							; Not if the object wouldn't normally sell it
							(not (objGetSellPrice theObj (itmCreate theUNID 1) 'noInventoryCheck))
								Nil

							; Otherwise, add the reactor to the list
							(itmCreate theUNID 1)
							)
						))

					; Append any reactors that the object happens to have. But 
					; make sure that we don't duplicate.
					(setq additionalList (map (objGetItems theObj "rNU") 'excludeNil theItem
						(switch
							; Not if we already have it in our list
							(find reactorList (itmSetCount theItem 1))
								Nil

							; If this reactor has less power than the player's
							; current reactor, then skip it.
							(leq (typGetDataField (itmGetType theItem) 'power) minPower)
								Nil

							; Not if the object wouldn't normally sell it
							(not (objGetSellPrice theObj theItem 'noInventoryCheck))
								Nil

							; Add it
							theItem
							)
						))

					; Return the list
					(append reactorList additionalList)
					)
				))

			(setq rpgInstallDevicePrep (lambda (data)

				; Data must have the following fields
				;
				;	item:					The item to install
				;
				; In addition, the following optional fields are supported
				;
				;	buyAndInstall:			If True, we're installing as part of purchase
				;	checkMilitaryID:		If True, we check for military ID, if necessary
				;	checkTotalPower:		If True, we fail unless the total power of all devices matches reactor output
				;	currencyUsed:			The currency used
				;	installerObj:			Object installing the device (if Nil, we assume a station)
				;	installPriceAdj:		Installation price (only if totalPrice is Nil)
				;	itemInCargo:			If True, item is in player's cargo hold
				;	maxTechLevel:			The maximum tech level we will install (unless we match techCriteriaOverride)
				;	noCargoCheck:			If True, then we don't check to see if the old device fits in cargo
				;	replaceItem:			If not Nil, we try to replace this device.
				;	targetObj:				Object on which to install (if Nil, we assume player ship)
				;	techCriteria:			If not Nil, the item must match this criteria
				;	techCriteriaOverride:	If not Nil, and item matches this criteria, install even if above maxTechLevel
				;	totalPrice:				The total price to install (includes purchase price if buyAndInstall is True)
				;	upgrade:				If True, we are buying an item as an upgrade
				;
				; We return a struct with the following elements:
				;
				;	canInstall:				True if installation can proceed
				;	price:					Total installation cost
				;	desc:					Description of installation attempt

				(block (thisItem totalCost canInstall desc descWarning itemName currencyUsed targetObj installerObj textYourShip textWe textYour)
				
					(setq thisItem (@ data 'item))
					(setq currencyUsed (@ data 'currencyUsed))
					(setq targetObj (if (@ data 'targetObj) (@ data 'targetObj) gPlayerShip))
					(setq installerObj (if (@ data 'installerObj) (@ data 'installerObj) gSource))
					(if (not currencyUsed) (setq currencyUsed (objGetDefaultCurrency targetObj)))
					(setq itemName (itmGetName thisItem 0x04))
					;(setq itemName (itmGetName thisItem (if (or (@ data 'upgrade) (@ data 'buyAndInstall)) 0x40 0x04)))
					(setq canInstall Nil)
					
					;	If the target object is not the player's ship, then we need to modify
					;	some text
					
					(setq textYourShip
						(if (eq targetObj gPlayerShip)
							"your ship"
							(cat "the " (objGetName targetObj 0x00))
							)
						)
						
					(setq textWe
						(if (eq installerObj gPlayerShip)
							"you"
							"we"
							)
						)
						
					(setq textYour
						(if (eq targetObj gPlayerShip)
							"your"
							"the"
							)
						)
						
					(if thisItem
						(block (
							;	We use installDeviceStatus instead of installItemStatus because we
							;	don't want to install armor objects.
							
							(status (objGetItemProperty installerObj thisItem 'installDeviceStatus))
							(itemPrice 
								(if (or (@ data 'upgrade) (@ data 'buyAndInstall)) 
									(objGetSellPrice installerObj thisItem)
									0
									)
								)
							(recommendedSlot
								(switch
									(not (@ data 'replaceItem))
										-1
										
									(not (itmGetInstallPos (@ data 'replaceItem)))
										-1
										
									(itmGetInstallPos (@ data 'replaceItem))
									)
								)
							
							cargoNeeded itemToReplace resultMessage resultCode returnValue stationCannotInstall removeStatus
							)
						
							;	Compute the cost to install
							
							(switch
								(@ data 'totalPrice)
									(setq totalCost (@ data 'totalPrice))

								(@ data 'installPriceAdj)
									(setq totalCost (rpgAdjustInstallPrice Nil thisItem (@ data 'installPriceAdj) currencyUsed))
									
								(@ status 'canInstall)
									(setq totalCost	(add (@ status 'price) itemPrice))
									
								;	If we get this far, then we cannot install

								(block Nil
									(setq totalCost 0)
									(setq stationCannotInstall True)
									)
								)
								
							;	Ask the object is we can install the item

							(setq returnValue (objCanInstallItem targetObj thisItem recommendedSlot))
							(setq resultCode (@ returnValue 1))
							(setq resultMessage (@ returnValue 2))
							(setq itemToReplace (@ returnValue 3))
							
							(switch
								;	If not installable at this station, then ignore
								
								stationCannotInstall
									(if (@ status 'descID)
										(setq desc (objTranslate installerObj (@ status 'descID) { item:thisItem targetObj:targetObj }))
										(setq desc (cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip "."))
										)
									
								;	If we don't match the tech criteria then we don't have the
								;	technology to install.
								
								(and (@ data 'techCriteria)
										(not (itmMatches thisItem (@ data 'techCriteria)))
										)
									(setq desc (cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip "."))
								
								;	If our max tech level is too low for the item, then we can't install
								;	(except for specific items that we know about)
								
								(and (gr (itmGetLevel thisItem) (if (@ data 'maxTechLevel) (@ data 'maxTechLevel) 30))
										(or (not (@ data 'techCriteriaOverride))
											(not (itmMatches thisItem (@ data 'techCriteriaOverride)))
											)
										)
									(setq desc (cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip "."))

								(and (not totalCost)
										(gr (itmGetLevel thisItem) (objGetProperty installerObj 'installDeviceMaxLevel))
										)
									(setq desc (cat (strCapitalize textWe) " do not have the technology to install " itemName " on " textYourShip "."))

								(not totalCost)
									(setq desc (cat (strCapitalize textWe) " cannot install " itemName " on " textYourShip "."))
									
								;	Some stations only install an item if you purchase it from them.
								
								(and (@ status 'upgradeInstallOnly)
										(not (@ data 'upgrade))
										)
									(setq desc (cat "Sorry, installation services are only available for purchased upgrades."))
									
								;	Check military ID

								(and (@ data 'checkMilitaryID)
										(itmHasModifier thisItem "Military")
										(not (objGetItems targetObj "*+MilitaryID"))
										)
									(setq desc (cat "You must have a military ID to use " itemName "."))
									
								(and (@ data 'checkMilitaryID)
										(itmHasModifier thisItem "Illegal")
										)
									(setq desc "We do not install illegal items.")

								(eq resultCode 'cannotInstall)
									(setq desc resultMessage)

								(eq resultCode 'noDeviceSlotsLeft)
									(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
										(setq desc (cat (strCapitalize textYourShip) " does not have enough open device slots to install this device."))
										(setq desc (cat (strCapitalize textYourShip) " does not have an open device slot for this device."))
										)

								(eq resultCode 'reactorTooWeak)
									(setq desc (cat (strCapitalize textYourShip) "'s reactor is not powerful enough for this device."))

								(eq resultCode 'reactorIncompatible)
									(setq desc (cat "The power output of " itemName " is too high for " textYourShip "."))

								(eq resultCode 'noWeaponSlotsLeft)
									(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
										(setq desc (cat (strCapitalize textYourShip) " does not have enough open weapon slots to install this device."))
										(setq desc (cat (strCapitalize textYourShip) " does not have an open weapon slot for this device."))
										)
								
								(eq resultCode 'noNonWeaponSlotsLeft)
									(if (gr (itmGetProperty thisItem 'deviceSlots) 1)
										(setq desc (cat (strCapitalize textYourShip) " does not have enough open non-weapon slots to install this device."))
										(setq desc (cat (strCapitalize textYourShip) " does not have an open non-weapon slot for this device."))
										)
									
								(and (eq resultCode 'replacementRequired)
										(eq (itmGetType thisItem) (itmGetType itemToReplace))
										(eq (itmIsEnhanced thisItem) (itmIsEnhanced itemToReplace))
										(eq (itmGetProperty thisItem 'damaged) (itmGetProperty itemToReplace 'damaged))
										(geq (itmGetProperty thisItem 'charges) (itmGetProperty itemToReplace 'charges))
										)
									(setq desc (cat (strCapitalize textYourShip) " already has " itemName " (and cannot support more devices unless you remove one first)."))
									
								(eq resultCode 'replacementRequired)
									(block Nil
										(setq desc (cat (strCapitalize textWe) " can remove " textYour " " (itmGetName itemToReplace 0x80) " and install " itemName))
										(setq canInstall True)
										)
									
								(not (eq resultCode 'ok))
									(setq desc "This device cannot be installed.")

								(block Nil
									(setq desc (cat (strCapitalize textWe) " can install " itemName " on " textYourShip))
									(setq canInstall True)
									)
								)

							; If we need to remove a device, then it will cost more

							(setq cargoNeeded 0)
							(if (and canInstall itemToReplace)
								(block Nil
									(if (not (@ data 'totalPrice))
										(setq totalCost 
											(add totalCost (objGetItemProperty installerObj itemToReplace 'removeDevicePrice))
											)
										)

									; See how much cargo space we need to store the old item

									(setq cargoNeeded (itmGetMass itemToReplace))
									(if (@ data 'itemInCargo)
										(setq cargoNeeded (subtract cargoNeeded (itmGetMass thisItem)))
										)
									)
								)
								
							; See if we are allowed to remove the device
							
							(if (and canInstall itemToReplace
									(neq (setq removeStatus (shpCanRemoveDevice targetObj itemToReplace)) 0)
									)
								(block Nil
									(setq desc (cat desc ". " (if (isint removeStatus) "Unfortunately, you cannot remove the device." removeStatus)))
									(setq canInstall Nil)
									)
								)

							; See if the item fits

							(if (and canInstall
									(gr cargoNeeded (objGetCargoSpaceLeft targetObj))
									(not (@ data 'noCargoCheck))
									)
								(block Nil
									(setq desc (cat desc ". Unfortunately, there isn't enough room in your cargo hold to do the swap."))
									(setq canInstall Nil)
									)
								)

							; See if we can afford the installation

							(if canInstall
								(if (gr totalCost 0)
									(if (gr totalCost (objGetBalance targetObj currencyUsed))
										(block Nil
											(setq desc (cat desc " for " (fmtCurrency currencyUsed totalCost) ". Unfortunately, you cannot afford the cost."))
											(setq canInstall Nil)
											)
										(setq desc 
											(cat 
												desc " for " (if (@ data 'buyAndInstall) "an additional " "") 
												(if (or (@ data 'upgrade) (@ data 'installPriceAdj))
													(fmtCurrency currencyUsed totalCost)
													(fmtCurrency currencyUsed (subtract totalCost itemPrice))
													)
												"."
												)
											)
										)
										
									(if (not (eq installerObj gPlayerShip))
										(setq desc (cat desc " at no charge."))
										(setq desc (cat desc "."))
										)
									)
								)
								
							;	See if we are downgrading
							
							(if (and canInstall
									itemToReplace
									(ls (itmGetLevel thisItem) (itmGetLevel itemToReplace))
									(= (itmGetProperty thisItem 'category) (itmGetProperty itemToReplace 'category))
									(!= (itmGetProperty thisItem 'category) 'device)
									(!= (itmGetProperty thisItem 'category) 'cargoHold)
									)
								(setq descWarning (cat "Note: Your currently installed " (itmGetName itemToReplace 0x00) " is higher level."))
								)
							)
							
						(setq desc "You do not have any devices that can be installed.")
						)

					; Return variables
					{
						canInstall: canInstall
						price: totalCost
						desc: desc
						descWarning: descWarning
						}
					)
				))
				
			(setq rpgMissionAssignment (lambda (options)
			
				;	Options may contain the following fields
				;
				;		maxPerStation: Maximum number of missions that we give out at
				;				this station.
				;
				;		missionCriteria: Criteria used to create new missions. [Required]
				;
				;		noMissionTextID: Language ID to display if there is no mission
				;				available at this station. [Required]
				
				(block (
					(noMissionTextID (@ options 'noMissionTextID))
					theMission newMissions
					)

					;	Show proper screen

					(switch
						;	If we have an active mission from this station then we show it.

						(setq theMission (@ (msnFind gSource "aS") 0))
							(scrShowScreen gScreen &dsRPGMission; {	missionObj: theMission })

						;	If we have an open mission available then display it.

						(setq theMission (@ (msnFind gSource "oS") 0))
							(scrShowScreen gScreen &dsRPGMission; {	missionObj: theMission })

						;	Don't give out more than X mission per station
								
						(and (@ options 'maxPerStation) 
								(geq (count (msnFind gSource "*S")) (@ options 'maxPerStation))
								)
							(scrShowScreen gScreen &dsRPGMessage; { desc:(scrTranslate gScreen noMissionTextID) })

						;	Make a list of available missions. We filter out any missions
						;	that are outside our system level. If we can't find anything, then we've got nothing.

						(not (setq newMissions (typFind (@ options 'missionCriteria))))
							(scrShowScreen gScreen &dsRPGMessage; { desc:(scrTranslate gScreen noMissionTextID) })

						;	Create a random mission from the list. If we succeed, then show the mission
						;	screen.

						(setq theMission (msnCreate newMissions gSource))
							(scrShowScreen gScreen &dsRPGMission; { missionObj: theMission })

						; Otherwise, nothing

						(scrShowScreen gScreen &dsRPGMessage; { desc:(scrTranslate gScreen noMissionTextID) })
						)
					)
				))

			(setq rpgPageCount (lambda (textDesc)
				(if (isatom textDesc) 1 (count textDesc))
				))

			(setq rpgPageDesc (lambda (textDesc pageNo)
				(block (pageDesc)
					(switch
						(eq (typeof textDesc) 'struct)
							(setq pageDesc textDesc)

						(eq (typeof textDesc) 'string)
							(setq pageDesc {
								desc: textDesc
								})

						(eq (typeof (@ textDesc pageNo)) 'struct)
							(setq pageDesc (@ textDesc pageNo))

						(setq pageDesc {
							desc: (@ textDesc pageNo)
							})
						)

					(if (not (@ pageDesc 'desc))
						(set@ pageDesc 'desc "You have successfully completed the mission.")
						)

					(if (and (@ pageDesc 'nextLabel) (not (@ pageDesc 'nextKey)))
						(set@ pageDesc 'nextKey
							(@ (regex (@ pageDesc 'nextLabel) "{$?}*{{$A}+}{$?}*" 'subex) 1)
							)
						)

					pageDesc
					)
				))
				
			(setq rpgPagePaneInit (lambda (theScreen textDesc options)
				(block (
					(missionObj (scrGetData theScreen 'missionObj))
					(pageCount (rpgPageCount textDesc))
					(pageNo (if (scrGetData theScreen 'curPage) (scrGetData theScreen 'curPage) 0))
					(pageDesc (rpgPageDesc textDesc pageNo))
						
					atLastPage
					)
					
					; Show the appropriate page

					(scrSetDesc theScreen (@ pageDesc 'desc))

					; Next page

					(setq pageNo (add pageNo 1))
					(setq atLastPage (geq pageNo pageCount))

					;	Initialize actions
					
					(switch
						
						;	If we're not at the last page, we always set the continue
						;	action and hide the others.
						
						(not atLastPage)
							(block Nil
								(scrShowAction theScreen 'actionContinue True)
								(if (@ pageDesc 'nextLabel)
									(scrSetActionLabel theScreen 'actionContinue (@ pageDesc 'nextLabel) (@ pageDesc 'nextKey))
									)
									
								(if (@ options 'acceptDecline)
									(block Nil
										(scrShowAction theScreen 'actionAccept Nil)
										(scrShowAction theScreen 'actionDecline Nil)
										)
										
									(scrShowAction theScreen 'actionDone Nil)
									)
								)
								
						;	If we've got accept/decline buttons, show them
						
						(@ options 'acceptDecline)
							(block (
								(acceptLabel (if (@ pageDesc 'acceptLabel)
									(@ pageDesc 'acceptLabel)
									(msnTranslate missionObj 'AcceptLabel (typTranslate &dsRPGMission; 'actionAccept))
									))
								(declineLabel (if (@ pageDesc 'declineLabel)
									(@ pageDesc 'declineLabel)
									(msnTranslate missionObj 'DeclineLabel (typTranslate &dsRPGMission; 'actionDecline))
									))
								)
								
								(scrShowAction theScreen 'actionContinue Nil)
								
								(scrShowAction theScreen 'actionAccept True)
								(scrSetActionLabel theScreen 'actionAccept acceptLabel)
								
								(scrShowAction theScreen 'actionDecline atLastPage)
								(scrSetActionLabel theScreen 'actionDecline declineLabel)
								)
								
						;	Otherwise, enable the done button
						
						(block Nil
							(scrShowAction theScreen 'actionContinue Nil)
							(scrShowAction theScreen 'actionDone True)
							(if (@ pageDesc 'nextLabel)
								(scrSetActionLabel theScreen 'actionDone (@ pageDesc 'nextLabel) (@ pageDesc 'nextKey))
								)
							)
						)
					
					; Remember page

					(scrSetData theScreen 'curPage (if atLastPage Nil pageNo))
					)
				))

			(setq rpgRestorePlayer (lambda ()

			; Repairs and restores the player's ship and places it at a random, safe
			; position in the system.

				(block (portObj newPos)

					; Find the nearest friendly station in the system
					(setq portObj (sysFindObject gPlayerShip "TAFN +populated; -occupation;"))
					(if (not portObj)
						(enumwhile (sysFindObject gPlayerShip "tF") (not portObj) theObj
							(if (not (sysFindObject theObj "sTEN:75"))
								(setq portObj theObj)
								)
							)
						)
					(if (not portObj)
						(setq portObj (sysFindObject gPlayerShip "tFN"))
						)

					; Pick a random position
					(setq newPos (sysVectorRandom portObj (random 30 40) 10 "t"))

					; Place the ship there
					(objMoveTo gPlayerShip newPos)

					; Repair the ship
					(intArmorRepairAll gPlayerShip 25 'alwaysRepair)
					(intDeviceRepairAll gPlayerShip)
					(shpRechargeShield gPlayerShip 1000)
					(shpRefuelFromItem gPlayerShip (itmCreate &itHelium3FuelRod; (shpGetFuelNeeded gPlayerShip (itmCreate &itHelium3FuelRod; 1))))
					(objChangeEquipmentStatus gPlayerShip 'SRS 'repair)
					(objFixParalysis gPlayerShip)
					(shpDecontaminate gPlayerShip)
					
					; Remove any overlays that shouldn't be there (e.g., pteravores)
					(enum (objGetOverlays gPlayerShip) theOverlay
						(objFireOverlayEvent gPlayerShip theOverlay "OnInsuranceClaim")
						)
					)
				))
			)
	</Globals>

</TranscendenceModule>